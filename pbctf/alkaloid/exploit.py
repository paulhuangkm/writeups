import random
from output import ori_public, enc
import time
import copy

def keygen(ln):
    # Generate a linearly independent key
    arr = [ 1 << i for i in range(ln) ]

    for i in range(ln):
        for j in range(i):
            if random.getrandbits(1):
                arr[j] ^= arr[i]
    for i in range(ln):
        for j in range(i):
            if random.getrandbits(1):
                arr[ln - 1 - j] ^= arr[ln - 1 - i]

    return arr

def gen_keystream(key):
    ln = len(key)
    
    # Generate some fake values based on the given key...
    fake = [0] * ln
    for i in range(ln):
        for j in range(ln // 3):
            if i + j + 1 >= ln:
                break
            fake[i] ^= key[i + j + 1]

    # Generate the keystream
    res = []
    for i in range(ln):
        t = random.getrandbits(1)
        if t:
            res.append((t, [fake[i], key[i]]))
        else:
            res.append((t, [key[i], fake[i]]))

    # Shuffle!
    random.shuffle(res)

    keystream = [v[0] for v in res]
    public = [v[1] for v in res]
    return keystream, public

def xor(a, b):
    return [x ^ y for x, y in zip(a, b)]

def recover_keystream(key, public):
    st = set(key)
    keystream = []
    for v0, v1 in public:
        if v0 in st:
            keystream.append(0)
        elif v1 in st:
            keystream.append(1)
        else:
            assert False, "Failed to recover the keystream"
    return keystream

def bytes_to_bits(inp):
    res = []
    for v in inp:
        res.extend(list(map(int, format(v, '08b'))))
    return res

def bits_to_bytes(inp):
    res = []
    for i in range(0, len(inp), 8):
        res.append(int(''.join(map(str, inp[i:i+8])), 2))
    return bytes(res)

ln = len(ori_public)
print(len(ori_public))
print(len(enc))
key = [0] * ln
idx = ln-1
all_xor = 0

tmp_public = copy.deepcopy(ori_public)
for i in range(ln // 3):
    for j, (v1, v2) in enumerate(tmp_public):
        if v2 == all_xor:
            del tmp_public[j]
            key[idx] = v1
            all_xor ^= key[idx]
            idx -= 1
            break
        elif v1 == all_xor:
            del tmp_public[j]
            key[idx] = v2
            all_xor ^= key[idx]
            idx -= 1
            break

for i in range(2 * ln // 3):
    for j, (v1, v2) in enumerate(tmp_public):
        if v2 == all_xor:
            del tmp_public[j]
            key[idx] = v1
            all_xor ^= key[idx]
            all_xor ^= key[idx+200]
            idx -= 1
            break
        elif v1 == all_xor:
            del tmp_public[j]
            key[idx] = v2
            all_xor ^= key[idx]
            all_xor ^= key[idx+200]
            idx -= 1
            break

count = 0
for i in range(ln):
    if key[i]:
        count += 1
assert count == len(ori_public)
# print(key)
keystream = recover_keystream(key, ori_public)
flag = bytes_to_bits(enc)
flag = bits_to_bytes(xor(flag, keystream))
print(flag)